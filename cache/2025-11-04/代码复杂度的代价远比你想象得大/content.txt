[ ![](https://img2024.cnblogs.com/blog/35695/202510/35695-20251025102907236-509444921.jpg) ](https://qoder.cnblogs.com/)
  * [ ![博客园logo](https://assets.cnblogs.com/logo.svg) ](https://www.cnblogs.com/ "开发者的网上家园")
  * [会员](https://cnblogs.vip/)
  * [众包](https://www.cnblogs.com/cmt/p/18500368)
  * [新闻](https://news.cnblogs.com/)
  * [博问](https://q.cnblogs.com/)
  * [闪存](https://ing.cnblogs.com/)
  * [赞助商](https://www.cnblogs.com/cmt/p/19081960)
  * [HarmonyOS](https://harmonyos.cnblogs.com/)
  * [Chat2DB](https://chat2db-ai.com/)


  * ![搜索](https://assets.cnblogs.com/icons/search.svg) ![搜索](https://assets.cnblogs.com/icons/enter.svg)
    * ![搜索](https://assets.cnblogs.com/icons/search.svg)
所有博客
    * ![搜索](https://assets.cnblogs.com/icons/search.svg)
当前博客
  * [ ![写随笔](https://assets.cnblogs.com/icons/newpost.svg) ](https://i.cnblogs.com/EditPosts.aspx?opt=1 "写随笔") [ ![我的博客](https://assets.cnblogs.com/icons/myblog.svg) ](https://passport.cnblogs.com/GetBlogApplyStatus.aspx "我的博客") [ ![短消息](https://assets.cnblogs.com/icons/message.svg) ](https://msg.cnblogs.com/ "短消息") [ ![简洁模式](https://assets.cnblogs.com/icons/lite-mode-on.svg) ](javascript:void\(0\) "简洁模式启用，您在访问他人博客时会使用简洁款皮肤展示")
[ ![用户头像](https://assets.cnblogs.com/icons/avatar-default.svg) ](https://home.cnblogs.com/)
[我的博客](https://passport.cnblogs.com/GetBlogApplyStatus.aspx) [我的园子](https://home.cnblogs.com/) [账号设置](https://account.cnblogs.com/settings/account) [会员中心](https://vip.cnblogs.com/my) [ 简洁模式 ... ](javascript:void\(0\) "简洁模式会使用简洁款皮肤显示所有博客") [退出登录](javascript:void\(0\))
[注册](https://account.cnblogs.com/signup) [登录](javascript:void\(0\);)


[![返回主页](https://www.cnblogs.com/skins/custom/images/logo.gif)](https://www.cnblogs.com/rude3knife/)
#  [蛮三刀酱](https://www.cnblogs.com/rude3knife)
## 技术公众号：后端技术漫谈 生活公众号：蛮三刀酱
  * [ 博客园](https://www.cnblogs.com/)
  * [ 首页](https://www.cnblogs.com/rude3knife/)
  * [ 新随笔](https://i.cnblogs.com/EditPosts.aspx?opt=1)
  * [ 联系](https://msg.cnblogs.com/send/%E8%9B%AE%E4%B8%89%E5%88%80%E9%85%B1)
  * [ 订阅](javascript:void\(0\))
  * [ 管理](https://i.cnblogs.com/)


随笔 - 62  文章 - 0  评论 - 108  阅读 -  20万
#  [ 代码复杂度的代价远比你想象得大 ](https://www.cnblogs.com/rude3knife/p/19185476/code_complexity "发布于 2025-11-02 21:36")
## 引言：复杂度的代价远比你想象得大
在 Java 后端系统演进过程中，代码复杂度是影响可维护性、稳定性和迭代效率的核心因素。然而，复杂度往往被忽视，直到一次“小改动”引发线上事故，才被重新审视。
本文以“复杂度战争”为主题，系统性地探讨如何识别、评估和治理代码中的复杂性。本文不会停留在抽象原则，而是结合真实案例、Java 代码示例和可落地的工程实践，让你了解你应用的代码复杂度，以及一个优秀的开发同学应该做到的避免代码”腐烂“的最佳实践。
让我们以一些代码案例引入今天的话题。（文中代码案例皆为模拟案例）
### 案例一：圈复杂度过高导致大事故
在某一个大促开始的日子，订单创建接口在高峰期响应时间飙升，错误率突破 XX%。 紧急回滚？没有最近的发布记录。 最终排查日志发现，数据库连接池被耗尽，而根源竟是一次两周前的“微小优化”。
开发同学为了支持一个新的促销规则，在 `OrderService.createOrder()` 方法中加了这么一段逻辑：
```
if (user.isVip() && order.getTotalAmount().compareTo(BigDecimal.valueOf(100)) > 0) {
    try {
        Discount discount = promotionClient.getDiscount(order);
        if (discount != null && discount.isValid()) {
            order.setFinalPrice(order.getTotalAmount().subtract(discount.getValue()));
        } else {
            order.setFinalPrice(order.getTotalAmount());
        }
    } catch (Exception e) {
        // 静默失败，使用原价（开发本意是防崩）
        order.setFinalPrice(order.getTotalAmount());
    }
}


```

问题来了：这个 `catch (Exception e)` 不仅吞掉了业务异常，还捕获了 **数据库连接超时异常（SQLException）** ，导致外层事务未及时中断，线程持续等待，最终拖垮连接池。
而这个方法本身已有 350 行，嵌套层级达 6 层，圈复杂度高达 **38** —— 没有人意识到，这次“小修”成了压垮系统的最后一根稻草。
这不是孤例。类似的复杂度事故，正在无数系统中悄然上演。
### 案例二：重复代码引发的数据错乱
支付网关中，签名计算逻辑在 `AlipayProcessor`、`WechatPayProcessor` 等 7 个类中重复出现：
```
String sign = DigestUtils.md5Hex(data + secretKey).toUpperCase();

```

某天，安全团队要求升级为 SHA-256，但只改了其中 4 个实现类。剩下的 3 个渠道继续用 MD5，导致“无效签名”错误激增，影响数万笔交易。
工具扫描显示：**重复代码率达 12%** ，而这些“看起来一样”的代码，分散在不同模块，无人统一维护。
### 案例三：“上帝类”无人敢动
CRM 系统中的 `CustomerManager` 类长达 **2800 行** ，承担着客户创建、积分计算、消息推送、审计日志、缓存同步等 8 种职责。
更可怕的是，每次调用 `updateCustomer()`，都会触发一连串隐式行为：
```
public void updateCustomer(Customer customer) {
    customerRepo.save(customer);
    
    // 更新积分（即使只是改了个电话）
    rewardService.calculateReward(customer);
    
    // 推送消息（同步阻塞）
    messageQueue.send(buildUpdateMessage(customer));
    
    // 写审计日志
    auditLogService.log("UPDATE", customer.getId(), getCurrentUser());
    
    // 刷新缓存
    cacheService.evict("customer:" + customer.getId());
}

```

新来的工程师想改个字段校验逻辑，结果测出 5 个副作用 bug。从此，这个类成了团队心中的“禁区”。
### 案例四：微服务拆分后更慢了
物流平台将单体拆分为订单、路由、运力三个服务后，原本本地调用 `routeService.findOptimalRoute()` 的耗时从 50ms 变成 350ms（含网络+序列化+重试）。
而最致命的是，当路由服务不稳定时，订单服务因未配置熔断，持续重试，反向拖垮整个链路。
**复杂度没有消失，只是从“代码层面”转移到了“分布式层面”** 。
这些事件背后，都有一个共同敌人：**失控的代码复杂度** 。
它不像内存泄漏那样立刻崩溃系统，也不像权限漏洞那样被安全扫描抓出。它潜伏在每一次“先上线再说”的妥协里，在每一个没人敢动的类中，在每一段“还能看懂”的嵌套逻辑中，缓慢侵蚀系统的生命力。
而作为 Java 后端开发者，尤其是架构师，我们必须清醒地认识到：
> **系统的可维护性，不取决于功能多强大，而取决于它的复杂度是否可控。**
在这场看不见硝烟的 **复杂度战争** 中，我们不能靠运气取胜。我们需要工具来度量它，需要原则来约束它，更需要实战策略来持续降低它。
接下来，我们将深入探讨：
  * 哪些指标能真正衡量代码复杂度？
  * 如何用合理的工具发现系统中的“复杂度热点”？
  * 在日常编码中，如何写出高质量、低复杂度的 Java 代码？
  * 架构层面，又该如何从源头控制复杂度的增长？


## 代码复杂度的主流定义
当我们说一段代码“太复杂”时，往往是一种直觉判断。但真正的工程实践需要**可量化、可检测、可改进** 的指标。所谓“复杂度”，并不是指代码行数多，而是指**理解、维护、修改它的认知成本高** 。
在软件工程领域，已有多个被广泛认可的复杂度维度，它们从不同角度揭示代码的“健康状况”。
我们将逐一介绍这些指标的含义和实际案例，并按照其作用粒度分为三个层次：**方法级、类级、继承结构级** ，帮助你系统化地识别和治理复杂度。
### 1. 圈复杂度（Cyclomatic Complexity）
#### 定义
由 Thomas McCabe 提出，衡量程序中**独立执行路径的数量** 。路径越多，测试难度越大，出错概率越高。
计算规则：每有一个 `if`、`for`、`while`、`case`、`catch`，复杂度 +1；`else` 不加分。总分>5 需关注
#### 危害
  * 路径爆炸 → 难以覆盖所有分支
  * 异常处理易遗漏
  * 修改风险高，容易引入副作用


#### 实际案例
```
public BigDecimal calculateFinalPrice(Order order, User user, boolean hasCoupon) {
    BigDecimal total = order.getItems().stream()
        .map(Item::getPrice)
        .reduce(BigDecimal.ZERO, BigDecimal::add);

    if (total.compareTo(BigDecimal.valueOf(100)) > 0) {           // +1
        if (user.isVip()) {                                       // +2
            total = total.multiply(BigDecimal.valueOf(0.9));      // VIP 9折
        } else if (hasCoupon) {                                   // +3
            total = total.subtract(BigDecimal.valueOf(10));       // 减10元
        }
    }

    try {
        Promotion promotion = promotionClient.getActivePromotion(); // +4
        if (promotion != null && promotion.isValid()) {             // +5
            total = total.subtract(promotion.getDiscount());
        }
    } catch (RemoteException e) {                                   // +6
        log.warn("Failed to fetch promotion, using base price");
    }

    return total;
}

```

**该方法圈复杂度 = 6**
虽然不算极端，但已接近警戒线（>5 需关注）。若未来增加节日折扣、地区限制等条件，极易突破 10。
#### 改进方向
使用策略模式或规则引擎解耦判断逻辑，或将促销计算抽象为独立服务。
### 2. 嵌套深度（Nesting Depth）
#### 定义
代码块的嵌套层级，如 `if` 中套 `if`，再套 `for` 或 `try`。每增加一层，理解成本呈指数上升。。推荐阈值：**≤3 层** ，超过即应重构。
#### 实际案例：“左箭头综合征”
```
public boolean processRefund(RefundRequest request) {
    if (request != null) {
        Order order = orderService.findById(request.getOrderId());
        if (order != null) {
            if (order.getStatus() == OrderStatus.PAID) {
                PaymentRecord record = paymentService.findByOrder(order);
                if (record != null) {
                    try {
                        RefundResult result = paymentGateway.refund(record);
                        if (result.isSuccess()) {
                            refundRepo.save(new Refund(record, SUCCESS));
                            return true;
                        } else {
                            log.error("Refund failed: {}", result.getMessage());
                            return false;
                        }
                    } catch (PaymentException e) {
                        log.error("Payment system error", e);
                        return false;
                    }
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    } else {
        return false;
    }
}

```

嵌套达 **6 层** ，阅读需不断“缩进-回退”，极易漏判条件。
#### 改进方向
使用卫语句（Guard Clauses）提前返回
```
public boolean processRefund(RefundRequest request) {
    if (request == null) return false;

    Order order = orderService.findById(request.getOrderId());
    if (order == null || order.getStatus() != OrderStatus.PAID) return false;

    PaymentRecord record = paymentService.findByOrder(order);
    if (record == null) return false;

    try {
        RefundResult result = paymentGateway.refund(record);
        if (result.isSuccess()) {
            refundRepo.save(new Refund(record, SUCCESS));
            return true;
        } else {
            log.error("Refund failed: {}", result.getMessage());
            return false;
        }
    } catch (PaymentException e) {
        log.error("Payment system error", e);
        return false;
    }
}

```

逻辑扁平化，可读性显著提升。
### 3. 方法长度 & 类长度
#### 定义
  * **方法长度** ：单个方法的代码行数（不含空行和注释）
  * **类长度** ：单个类的总行数


> 经验阈值：
>   * 方法 ≤ 50 行
>   * 类 ≤ 500 行
> 

超出即可能违反 **单一职责原则（SRP）**
#### 实际案例：上帝方法
```
// 一个长达 320 行的 createOrder() 方法
// 包含：参数校验、库存扣减、价格计算、优惠应用、积分发放、消息推送、日志记录、异常重试……
public Order createOrder(CreateOrderRequest request) {
    // ... 320 行混合逻辑 ...
}

```

  * 无法单元测试所有路径
  * 任何改动都可能引发未知副作用
  * 新人完全看不懂执行流程


#### 改进方向
```
public Order createOrder(CreateOrderRequest request) {
    validateRequest(request);                    // 校验
    InventoryResult inv = inventoryService.deduct(request); // 扣库存
    PriceCalculation calc = priceEngine.calculate(request); // 算价
    Order order = orderRepo.save(mapToEntity(request, calc)); // 保存
    rewardService.awardPoints(order);            // 发积分
    eventPublisher.publish(new OrderCreatedEvent(order)); // 发事件
    return order;
}

```

每个步骤独立，便于替换、测试、监控。
### 4. 类级复杂度：CK Metrics 四大经典指标
在面向对象系统中，仅看行数和方法数量还不够。我们需要更精细的指标来评估一个类的设计质量。以下四个指标合称 **CK Metrics Suite** （Chidamber & Kemerer），是业界公认的类复杂度评估标准。
#### （1）WMC（Weighted Methods per Class）
**类的方法圈复杂度加权和**
  * 含义：一个类中所有方法的圈复杂度之和
  * 示例：若某类有 5 个方法，圈复杂度分别为 6、8、5、12、4，则 WMC = 35
  * 危害：WMC 越高，表示该类整体逻辑密度大，维护和测试成本高
  * 建议阈值：**≤45** ，否则应考虑拆分


> WMC 是对“类长度”的深化 —— 它不仅看有多少方法，更关注这些方法有多复杂。
#### （2）CBO（Coupling Between Object Classes）
**类间耦合度**
  * 含义：一个类所依赖的外部类的数量
  * 关联概念：你在“依赖复杂度”一节中提到的 **Efferent Coupling（Ce）** 本质上就是 CBO
  * 危害：CBO 高 → 耦合强 → 变动牵一发而动全身，不利于复用
  * 建议阈值：**≤7**


> 小结：CBO 和 Efferent Coupling 指标一致，只是术语来源不同。现代工具如 SonarQube 使用后者，但在学术和架构评审中，“CBO”仍是通用说法。
#### （3）RFC（Response for a Class）
**类的响应集**
  * 含义：一个类能直接或间接响应的方法总数，包括自身方法 + 它调用的外部方法
  * 示例：`OrderService.create()` 调用了 `paymentService.pay()` 和 `rewardService.award()`，则这两个调用也计入 RFC
  * 危害：RFC 越大，表示该类的行为影响面越广，测试组合爆炸，理解成本上升
  * 建议阈值：**≤50**


#### （4）LCOM（Lack of Cohesion in Methods）
**方法间内聚性缺失**
  * 含义：衡量类中方法是否共享相同的字段。如果方法分为几组，各自操作不同的属性，则 LCOM 高

```
class User {
    private String name, email;
    private int loginCount;
    // updateProfile() 只用 name/email
    // incrementLogin() 只用 loginCount
    // → LCOM 高，说明职责不聚焦
}


```

  * 危害：LCOM 高 → 类缺乏内聚性 → 实际上承担了多个职责 → 应拆分
  * 改进方向：识别方法访问的字段簇，按业务边界进行类拆分


### 5. 继承结构复杂度
当系统使用继承时，还需关注类层次结构本身的复杂性。
#### （1）DIT（Depth of Inheritance Tree）
**继承树深度**
  * 含义：从当前类到根类的最大路径长度
  * 示例：`Animal → Mammal → Dog`，Dog 的 DIT = 2
  * 危害：DIT 越深，行为越难预测（父类逻辑隐式传递），调试困难
  * 建议：**DIT ≤ 3** ，过深应考虑改用组合


#### （2）NOC（Number of Children）
**子类数量**
  * 含义：一个类的直接子类个数
  * 危害：NOC 过大（如 >10）说明父类抽象不够通用，或继承体系设计不合理
  * 改进方向：提取共性接口，或使用策略模式替代继承


### 6. 重复代码率（Duplication）
#### 定义
系统中相同或高度相似代码块的比例。违背 DRY（Don't Repeat Yourself）原则。
#### 实际案例：到处复制的签名逻辑
```
// 在 AlipayProcessor 中
String sign = DigestUtils.md5Hex(data + apiKey).toUpperCase();

// 在 WechatPayProcessor 中（一模一样）
String sign = DigestUtils.md5Hex(data + apiKey).toUpperCase();

// 在 UnionpayProcessor 中（还是一样）
String sign = DigestUtils.md5Hex(data + apiKey).toUpperCase();


```

#### 改进：提取公共服务
```
@Component
public class SignatureService {
    public String sign(String data, String key) {
        return DigestUtils.sha256Hex(data + key).toUpperCase();
    }
}

```

### 总结
层级 | 指标 | 推荐阈值 | 主要危害  
---|---|---|---  
**方法级** | 圈复杂度 | ≤10 | 路径爆炸，难测试  
| 嵌套深度 | ≤3 | 可读性差  
| 方法长度 | ≤50 行 | 职责不清  
**类级** | 类长度 | ≤500 行 | 上帝类风险  
| WMC | ≤45 | 整体逻辑密度过高  
| CBO / Ce | ≤7 | 耦合高，难维护  
| RFC | ≤50 | 行为泛滥，测试难  
| LCOM | 值越高越差 | 内聚不足，应拆分  
**继承级** | DIT | ≤3 | 行为隐式传递  
| NOC | 不宜过大 | 抽象不充分  
**重复代码** | DRY | 不宜过多 | 不要重复自己  
## 复杂度评估工具
要打赢复杂度战争，光靠人工 Code Review 远远不够。我们需要一套自动化的评估体系，在开发、提交、构建、部署的每个环节持续监控代码质量。
以下是目前 Java 生态中主流的复杂度评估方案与工具框架，它们可以单独使用，也可集成形成完整的质量门禁体系。
### 1. SonarQube：行业标准的静态分析平台
SonarQube 是目前最广泛使用的代码质量管理平台，支持对圈复杂度、重复率、代码坏味、测试覆盖率等指标进行可视化分析和阈值控制。
核心能力：
  * 自动计算每个方法的圈复杂度，并标记 >10 的热点
  * 检测重复代码块，支持跨文件识别
  * 提供“技术债”估算：修复所有问题需要多少人天
  * 支持 Quality Gate（质量门禁）：CI 中断机制


集成方式：
```
<!-- Maven 配置示例 -->
<plugin>
    <groupId>org.sonarsource.scanner.maven</groupId>
    <artifactId>sonar-maven-plugin</artifactId>
    <version>3.9.1.2184</version>
</plugin>

```

执行扫描：
```
mvn sonar:sonar \ -Dsonar.projectKey=my-app \ -Dsonar.host.url=http://localhost:9000 \ -Dsonar.login=your-token

```

推荐规则集：
  * `cognitive-complexity`：认知复杂度警告
  * `nested-if-else-depth`：嵌套深度检测
  * `function-complexity`：方法复杂度阈值
  * `duplicated-blocks`：重复代码告警


### 2. IntelliJ IDEA 内置分析工具
IntelliJ 提供了强大的本地静态分析功能，开发者无需离开 IDE 即可发现复杂度问题。
由于 IDEA 迭代很快，使用方式各位开发同学可以自行搜索，
优点：即时反馈，适合在编码阶段预防问题。
### 3. PMD 与 Checkstyle：轻量级静态检查工具
两者常配合使用，用于 CI/CD 流水线中的自动化检查。
PMD 特点：
  * 专注代码结构问题
  * 内建规则：`ExcessiveMethodLength`, `CyclomaticComplexity`, `NestedIfDepth`


具体使用方式不展开描述了，大家可以自行查阅。
### 4. ArchUnit：架构层面的依赖约束
ArchUnit 允许你用 Java 代码定义架构规则，防止模块间非法依赖。
### 5. GitHub Actions / Jenkins 集成：将复杂度检查纳入 CI
通过 CI 脚本自动运行分析工具，实现“不达标不合并”。
GitHub Actions 示例：
```
name: Code Quality
on: [push, pull_request]
jobs:
  sonar:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up JDK
        uses: actions/setup-java@v3
        with:
          java-version: '17'
      - name: Run SonarQube Analysis
        run: mvn verify sonar:sonar -Dsonar.qualitygate.wait=true
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}


```

当质量门禁失败时，PR 将被阻断，强制开发者先修复问题。
### 总结
工具 | 适用场景 | 关键能力  
---|---|---  
SonarQube | 团队级质量管控 | 可视化 + 质量门禁  
IntelliJ | 个人开发阶段 | 实时提示  
PMD / Checkstyle | CI 自动化检查 | 规则驱动  
ArchUnit | 架构治理 | 依赖断言  
CI/CD 集成 | 流程卡点 | 强制合规  
## 面向低复杂度的代码最佳实践
知道什么是复杂度还不够，关键是如何在日常编码中主动降低它。本着面向代码最佳实践的原则，尝试总结几条有效降低代码复杂的 Best Practise
### 原则一：单一职责
一个类或方法应该只做一件事。职责越清晰，修改影响面越小。
#### 反例：多功能服务类
```
@Service
public class OrderService {
    public void createOrder() { /* 创建 */ }
    public void sendNotification() { /* 发送通知 */ }
    public void calculateReward() { /* 计算积分 */ }
    public void logAudit() { /* 写审计日志 */ }
}


```

这个类承担了订单生命周期的多个角色，任何变更都可能引发副作用。
#### 改进：按职责拆分
```
@Service
public class OrderCreationService { ... }

@Service
public class OrderNotificationService { ... }

@Service
public class OrderRewardCalculationService { ... }

```

职责分离后，各模块可独立测试、演进。
### 原则二：优先组合，而非继承
继承容易导致深层类层次结构，增加理解和维护成本。组合更灵活、更可控。
#### 反例：继承滥用
```
class BasePaymentProcessor { }
class AlipayProcessor extends BasePaymentProcessor { }
class WechatPayProcessor extends BasePaymentProcessor { }
class HybridAlipayProcessor extends AlipayProcessor { } // 多层继承

```

子类隐式继承父类行为，难以预测执行逻辑。
#### 改进：使用策略模式 + 组合
```
public interface PaymentStrategy {
    PaymentResult pay(BigDecimal amount);
}

@Service
public class AlipayStrategy implements PaymentStrategy { ... }

@Service
public class WechatPayStrategy implements PaymentStrategy { ... }

// 组合使用
public class UnifiedPaymentService {
    private final Map<String, PaymentStrategy> strategies;

    public UnifiedPaymentService(Map<String, PaymentStrategy> strategies) {
        this.strategies = strategies;
    }

    public PaymentResult pay(String type, BigDecimal amount) {
        return strategies.get(type).pay(amount);
    }
}


```

解耦清晰，扩展性强。
### 原则三：善用函数式编程减少状态污染
Java 8 引入的 `Optional` 和 `Stream` 不仅是语法糖，更是对抗复杂度的利器。
#### 反例：消除 null 嵌套判断
```
// 传统写法：多层 if 判断
if (user != null) {
    Cart cart = user.getCart();
    if (cart != null) {
        List<Item> items = cart.getItems();
        if (items != null && !items.isEmpty()) {
            return items.stream().map(Item::getPrice).reduce(BigDecimal::add).orElse(ZERO);
        }
    }
}
return ZERO;


```

#### 改进：改为 Optional 链式调用
```
return Optional.ofNullable(user)
    .map(User::getCart)
    .map(Cart::getItems)
    .filter(items -> !items.isEmpty())
    .flatMap(items -> items.stream().map(Item::getPrice).reduce(BigDecimal::add))
    .orElse(ZERO);

```

逻辑扁平化，无嵌套，可读性显著提升。
### 原则四：设计模式不是炫技，而是解耦武器
合理使用设计模式可以有效分解复杂逻辑，但切忌过度设计。
#### 反例：if-else
```
// 反例：一堆 if-else
if ("alipay".equals(type)) {
    return alipayClient.pay(amount);
} else if ("wechat".equals(type)) {
    return wechatClient.pay(amount);
} else if ("unionpay".equals(type)) {
    return unionpayClient.pay(amount);
}


```

#### 改进： 合理的设计模式
```
@Component
public class PaymentRouter {
    private final Map<String, PaymentClient> clients;

    public PaymentRouter(List<PaymentClient> clientList) {
        this.clients = clientList.stream()
            .collect(Collectors.toMap(PaymentClient::getType, c -> c));
    }

    public PaymentResult pay(String type, BigDecimal amount) {
        PaymentClient client = clients.get(type);
        if (client == null) throw new UnsupportedPaymentTypeException(type);
        return client.pay(amount);
    }
}


```

新增支付方式只需实现接口并注册 Bean，无需修改路由逻辑。
### 原则五：命名即文档，好名字胜过千行注释
变量、方法、类的命名应准确传达其意图，避免缩写和模糊词汇。
#### 反例：含义不明的数值枚举
```
public List<Order> getList(int status) { ... } // status 是什么？1 表示成功？

```

#### 改进：明确的枚举
```
public List<Order> findOrdersByStatus(OrderStatus status) { ... }

```

再如：
```
// 不清楚用途
private boolean flag;

// 明确语义
private boolean isEligibleForDiscount;


```

清晰的命名能让代码自解释，大幅降低理解成本。
### 原则六：防御性编程 + 清晰的错误处理
提前拦截非法输入，明确异常路径，避免静默失败。
#### 正例：使用卫语句提前返回
```
public Order createOrder(CreateOrderRequest request) {
    if (request == null) {
        throw new IllegalArgumentException("Request cannot be null");
    }
    if (request.getItems() == null || request.getItems().isEmpty()) {
        throw new IllegalArgumentException("Order must have items");
    }
    // 正常逻辑开始……
}

```

#### 正例：异常不要被吞掉
```
// 错误做法
catch (Exception e) {
    log.warn("Ignore error"); // 静默吞掉
}

// 正确做法
catch (PaymentTimeoutException e) {
    log.error("Payment system timeout", e);
    throw new OrderCreationFailedException("Payment failed due to timeout", e);
}


```

确保异常传播路径清晰，便于定位问题。
### 小结：高质量代码的共同特征
原则 | 关键动作 | 效果  
---|---|---  
单一职责 | 拆分类与方法 | 降低变更风险  
组合优于继承 | 使用接口 + 注入 | 提升灵活性  
函数式思维 | 使用 Optional/Stream | 减少嵌套  
设计模式 | 策略、工厂、责任链 | 解耦复杂逻辑  
清晰命名 | 表达业务意图 | 自解释代码  
防御性编程 | 提前校验 + 明确异常 | 提高健壮性  
这些原则不是教条，而是在长期实践中总结出的经验。坚持使用，你会发现自己写的代码越来越干净，系统也越来越稳健。
## 总结：坚持做正确的事
我们回顾一下最初的那几个问题：
  * 一个 `catch (Exception e)` 真的只是“防崩”吗？
  * 一段重复的签名逻辑，值得花几分钟复制粘贴吗？
  * 一个 2800 行的类，真的是“历史原因”无法改动吗？


答案从来都不是“代码本身有多难”，而是**我们是否愿意为系统的长期健康付出短期成本** 。
优秀的程序员不追求炫技式的“高复杂架构”，而是坚持写**低复杂度、高表达力** 的代码。他们知道，**可维护性才是系统最核心的非功能需求** 。
工具可以帮助我们发现问题，原则可以指导我们重构代码，但最终，守护系统整洁的，是每一位工程师对质量的敬畏之心。
posted @ 2025-11-02 21:36 [蛮三刀酱](https://www.cnblogs.com/rude3knife) 阅读(2106) 评论(9) [收藏](javascript:void\(0\)) [举报](javascript:void\(0\))
[刷新页面](https://www.cnblogs.com/rude3knife/p/19185476/code_complexity)[返回顶部](https://www.cnblogs.com/rude3knife/p/19185476/code_complexity#top)
登录后才能查看或发表评论，立即 [登录](javascript:void\(0\);) 或者 [逛逛](https://www.cnblogs.com/) 博客园首页 
[ ![](https://img2024.cnblogs.com/blog/35695/202510/35695-20251013111242110-2029482428.jpg) ](https://qoder.com/)
### 公告
昵称： [ 蛮三刀酱 ](https://home.cnblogs.com/u/rude3knife/)   
园龄： [ 5年3个月 ](https://home.cnblogs.com/u/rude3knife/ "入园时间：2020-07-12")   
粉丝： [ 76 ](https://home.cnblogs.com/u/rude3knife/followers/)   
关注： [ 0 ](https://home.cnblogs.com/u/rude3knife/followees/)
|  [<](javascript:void\(0\);) | 2025年11月 |  [>](javascript:void\(0\);)  
---|---|---  
日 | 一 | 二 | 三 | 四 | 五 | 六  
26 | 27 | 28 | 29 | 30 | 31 |  1   
[_2_](https://www.cnblogs.com/rude3knife/p/archive/2025/11/02) |  3  |  4  |  5  |  6  |  7  |  8   
9  |  10  |  11  |  12  |  13  |  14  |  15   
16  |  17  |  18  |  19  |  20  |  21  |  22   
23  |  24  |  25  |  26  |  27  |  28  |  29   
30  |  1  |  2  |  3  |  4  |  5  |  6   
### 搜索
###  常用链接 
  * [我的随笔](https://www.cnblogs.com/rude3knife/p/ "我的博客的随笔列表")
  * [我的评论](https://www.cnblogs.com/rude3knife/MyComments.html "我的发表过的评论列表")
  * [我的参与](https://www.cnblogs.com/rude3knife/OtherPosts.html "我评论过的随笔列表")
  * [最新评论](https://www.cnblogs.com/rude3knife/comments "我的博客的评论列表")
  * [我的标签](https://www.cnblogs.com/rude3knife/tag/ "我的博客的标签列表")


### [我的标签](https://www.cnblogs.com/rude3knife/tag/)
  * [系统设计(12)](https://www.cnblogs.com/rude3knife/tag/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/)
  * [Java(10)](https://www.cnblogs.com/rude3knife/tag/Java/)
  * [算法(8)](https://www.cnblogs.com/rude3knife/tag/%E7%AE%97%E6%B3%95/)
  * [秒杀系统(5)](https://www.cnblogs.com/rude3knife/tag/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/)
  * [数据库(5)](https://www.cnblogs.com/rude3knife/tag/%E6%95%B0%E6%8D%AE%E5%BA%93/)
  * [WebSocket(4)](https://www.cnblogs.com/rude3knife/tag/WebSocket/)
  * [MySQL(4)](https://www.cnblogs.com/rude3knife/tag/MySQL/)
  * [程序人生(3)](https://www.cnblogs.com/rude3knife/tag/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/)
  * [MacBook(3)](https://www.cnblogs.com/rude3knife/tag/MacBook/)
  * [M1(3)](https://www.cnblogs.com/rude3knife/tag/M1/)
  * [更多](https://www.cnblogs.com/rude3knife/tag/)


###  合集 
  * [AI(4)](https://www.cnblogs.com/rude3knife/collections/307)


###  [随笔分类](https://www.cnblogs.com/rude3knife/post-categories)
  * [《萌新写开源》系列(3)](https://www.cnblogs.com/rude3knife/category/2058504.html)
  * [程序员面试(6)](https://www.cnblogs.com/rude3knife/category/1826915.html)
  * [后端开发实战(24)](https://www.cnblogs.com/rude3knife/category/1804895.html)
  * [精彩分享(8)](https://www.cnblogs.com/rude3knife/category/2014689.html)
  * [秒杀系统实战(5)](https://www.cnblogs.com/rude3knife/category/1804894.html)
  * [爬虫实战(2)](https://www.cnblogs.com/rude3knife/category/1833218.html)
  * [我的程序人生(7)](https://www.cnblogs.com/rude3knife/category/1891368.html)
  * [线上问题排查(5)](https://www.cnblogs.com/rude3knife/category/1817573.html)


###  随笔档案 
  * [2025年11月(1)](https://www.cnblogs.com/rude3knife/p/archive/2025/11)
  * [2024年4月(1)](https://www.cnblogs.com/rude3knife/p/archive/2024/04)
  * [2023年11月(1)](https://www.cnblogs.com/rude3knife/p/archive/2023/11)
  * [2023年7月(2)](https://www.cnblogs.com/rude3knife/p/archive/2023/07)
  * [2023年4月(1)](https://www.cnblogs.com/rude3knife/p/archive/2023/04)
  * [2023年3月(1)](https://www.cnblogs.com/rude3knife/p/archive/2023/03)
  * [2023年1月(1)](https://www.cnblogs.com/rude3knife/p/archive/2023/01)
  * [2022年11月(1)](https://www.cnblogs.com/rude3knife/p/archive/2022/11)
  * [2022年6月(1)](https://www.cnblogs.com/rude3knife/p/archive/2022/06)
  * [2022年4月(1)](https://www.cnblogs.com/rude3knife/p/archive/2022/04)
  * [2022年1月(1)](https://www.cnblogs.com/rude3knife/p/archive/2022/01)
  * [2021年12月(2)](https://www.cnblogs.com/rude3knife/p/archive/2021/12)
  * [2021年11月(1)](https://www.cnblogs.com/rude3knife/p/archive/2021/11)
  * [2021年10月(1)](https://www.cnblogs.com/rude3knife/p/archive/2021/10)
  * [2021年9月(1)](https://www.cnblogs.com/rude3knife/p/archive/2021/09)
  * [2021年8月(3)](https://www.cnblogs.com/rude3knife/p/archive/2021/08)
  * [2021年7月(1)](https://www.cnblogs.com/rude3knife/p/archive/2021/07)
  * [2021年5月(2)](https://www.cnblogs.com/rude3knife/p/archive/2021/05)
  * [2021年3月(1)](https://www.cnblogs.com/rude3knife/p/archive/2021/03)
  * [2021年2月(2)](https://www.cnblogs.com/rude3knife/p/archive/2021/02)
  * [2021年1月(1)](https://www.cnblogs.com/rude3knife/p/archive/2021/01)
  * [2020年11月(2)](https://www.cnblogs.com/rude3knife/p/archive/2020/11)
  * [2020年10月(1)](https://www.cnblogs.com/rude3knife/p/archive/2020/10)
  * [2020年9月(1)](https://www.cnblogs.com/rude3knife/p/archive/2020/09)
  * [2020年8月(29)](https://www.cnblogs.com/rude3knife/p/archive/2020/08)
  * [2020年7月(2)](https://www.cnblogs.com/rude3knife/p/archive/2020/07)


###  [ 阅读排行榜 ](https://www.cnblogs.com/rude3knife/most-viewed)
  * [ 1. 一次完整的JVM堆外内存泄漏故障排查记录(27098) ](https://www.cnblogs.com/rude3knife/p/13570423.html)
  * [ 2. 一枚程序猿的MacBook M1详细体验报告(25520) ](https://www.cnblogs.com/rude3knife/p/14063991.html)
  * [ 3. 向量数据库Chroma极简教程(15688) ](https://www.cnblogs.com/rude3knife/p/chroma_tutorial.html)
  * [ 4. 如何保证同事的代码不会腐烂？一文带你了解 Alibaba COLA 架构(13175) ](https://www.cnblogs.com/rude3knife/p/cola-architecture.html)
  * [ 5. MacBook M1 虚拟机安装Windows for ARM使用体验(10572) ](https://www.cnblogs.com/rude3knife/p/14588071.html)


###  [评论排行榜](https://www.cnblogs.com/rude3knife/most-commented)
  * [ 1. 2022年是最烂的一年吗？我的2022年终总结(22) ](https://www.cnblogs.com/rude3knife/p/17027023.html)
  * [ 2. 一次完整的JVM堆外内存泄漏故障排查记录(20) ](https://www.cnblogs.com/rude3knife/p/13570423.html)
  * [ 3. 一枚程序猿的MacBook M1详细体验报告(17) ](https://www.cnblogs.com/rude3knife/p/14063991.html)
  * [ 4. 模仿UP主，用Python实现一个弹幕控制的直播间！(13) ](https://www.cnblogs.com/rude3knife/p/15635306.html)
  * [ 5. 代码复杂度的代价远比你想象得大(9) ](https://www.cnblogs.com/rude3knife/p/19185476/code_complexity)


###  [推荐排行榜](https://www.cnblogs.com/rude3knife/most-liked)
  * [ 1. 代码复杂度的代价远比你想象得大(33) ](https://www.cnblogs.com/rude3knife/p/19185476/code_complexity)
  * [ 2. 2022年是最烂的一年吗？我的2022年终总结(17) ](https://www.cnblogs.com/rude3knife/p/17027023.html)
  * [ 3. 模仿UP主，用Python实现一个弹幕控制的直播间！(14) ](https://www.cnblogs.com/rude3knife/p/15635306.html)
  * [ 4. 一次完整的JVM堆外内存泄漏故障排查记录(14) ](https://www.cnblogs.com/rude3knife/p/13570423.html)
  * [ 5. 一枚程序猿的MacBook M1详细体验报告(10) ](https://www.cnblogs.com/rude3knife/p/14063991.html)


### [最新评论](https://www.cnblogs.com/rude3knife/comments)
  * [1. Re:代码复杂度的代价远比你想象得大](https://www.cnblogs.com/rude3knife/p/19185476)
  * 查个折扣还得 跨服务，切分的也不好
  * --了悟
  * [2. Re:代码复杂度的代价远比你想象得大](https://www.cnblogs.com/rude3knife/p/19185476)
  * @星小梦 还有小重构和开发进度的不可调和(dogs)...
  * --漠泉
  * [3. Re:代码复杂度的代价远比你想象得大](https://www.cnblogs.com/rude3knife/p/19185476)
  * 第一个吞异常那个，你是分布式事务吧？
  * --星小梦
  * [4. Re:代码复杂度的代价远比你想象得大](https://www.cnblogs.com/rude3knife/p/19185476)
  * 很多都是正确的废话，实践中，就是各种条条框框逼着你去写大堆的if else。
  * --verification
  * [5. Re:代码复杂度的代价远比你想象得大](https://www.cnblogs.com/rude3knife/p/19185476)
  * 哪位举个处理 圈复杂度（Cyclomatic Complexity） 的例子。
  * --林Lin☆☆


[博客园](https://www.cnblogs.com/) © 2004-2025   
[![](https://assets.cnblogs.com/images/ghs.png)浙公网安备 33010602011771号](http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010602011771) [浙ICP备2021040463号-3](https://beian.miit.gov.cn)
点击右上角即可分享
![微信分享提示](https://img2023.cnblogs.com/blog/35695/202309/35695-20230906145857937-1471873834.gif)
