[ ![](https://img2024.cnblogs.com/blog/35695/202510/35695-20251025102907236-509444921.jpg) ](https://qoder.cnblogs.com/)
  * [ ![博客园logo](https://assets.cnblogs.com/logo.svg) ](https://www.cnblogs.com/ "开发者的网上家园")
  * [会员](https://cnblogs.vip/)
  * [众包](https://www.cnblogs.com/cmt/p/18500368)
  * [新闻](https://news.cnblogs.com/)
  * [博问](https://q.cnblogs.com/)
  * [闪存](https://ing.cnblogs.com/)
  * [赞助商](https://www.cnblogs.com/cmt/p/19081960)
  * [HarmonyOS](https://harmonyos.cnblogs.com/)
  * [Chat2DB](https://chat2db-ai.com/)


  * ![搜索](https://assets.cnblogs.com/icons/search.svg) ![搜索](https://assets.cnblogs.com/icons/enter.svg)
    * ![搜索](https://assets.cnblogs.com/icons/search.svg)
所有博客
    * ![搜索](https://assets.cnblogs.com/icons/search.svg)
当前博客
  * [ ![写随笔](https://assets.cnblogs.com/icons/newpost.svg) ](https://i.cnblogs.com/EditPosts.aspx?opt=1 "写随笔") [ ![我的博客](https://assets.cnblogs.com/icons/myblog.svg) ](https://passport.cnblogs.com/GetBlogApplyStatus.aspx "我的博客") [ ![短消息](https://assets.cnblogs.com/icons/message.svg) ](https://msg.cnblogs.com/ "短消息") [ ![简洁模式](https://assets.cnblogs.com/icons/lite-mode-on.svg) ](javascript:void\(0\) "简洁模式启用，您在访问他人博客时会使用简洁款皮肤展示")
[ ![用户头像](https://assets.cnblogs.com/icons/avatar-default.svg) ](https://home.cnblogs.com/)
[我的博客](https://passport.cnblogs.com/GetBlogApplyStatus.aspx) [我的园子](https://home.cnblogs.com/) [账号设置](https://account.cnblogs.com/settings/account) [会员中心](https://vip.cnblogs.com/my) [ 简洁模式 ... ](javascript:void\(0\) "简洁模式会使用简洁款皮肤显示所有博客") [退出登录](javascript:void\(0\))
[注册](https://account.cnblogs.com/signup) [登录](javascript:void\(0\);)


[![返回主页](https://www.cnblogs.com/skins/custom/images/logo.gif)](https://www.cnblogs.com/MeteorSeed/)
#  [MeteorSeed](https://www.cnblogs.com/MeteorSeed)
## 专注于.NET、AI、Godot...
  * [ 博客园](https://www.cnblogs.com/)
  * [ 首页](https://www.cnblogs.com/MeteorSeed/)
  * [ 订阅](javascript:void\(0\))
  * [ 管理](https://i.cnblogs.com/)


随笔 - 136  文章 - 0  评论 - 578  阅读 -  27万
#  [ C# 弃元模式：从语法糖到性能利器的深度解析 ](https://www.cnblogs.com/MeteorSeed/p/19131402 "发布于 2025-10-09 16:41")
在 C# 的语法演进中，“弃元（Discard）” 以一个简单的下划线 _ 成为了既提升代码可读性，又优化性能的 “双料特性”。它并非单纯的语法简化，而是编译器层面对 “有意忽略的值” 的深度优化 —— 通过明确 “忽略” 的意图，不仅让代码更简洁，更能减少内存分配、降低性能开销。本文将从使用场景、核心优势、性能验证到底层实现，全面解析弃元模式的价值。
# 什么是弃元模式？
弃元是 C# 7.0 引入的语法特性，用下划线 _ 表示 “有意忽略的变量”。它不是一个实际的变量，没有分配值，甚至未分配内存，也无法被访问（尝试使用会触发编译错误 CS0103 The name '_' doesn't exist in the current context）。其核心设计初衷是：通过统一的语法明确 “此值无关紧要”，让编译器和开发者都能清晰理解意图。
简单来说，弃元解决了一个长期存在的问题：如何优雅地处理 “必须接收但无需使用” 的值（如 out 参数、元组多余字段、default 分支等）。
# 应用场景
弃元的应用场景贯穿代码编写的多个环节，核心是 “用 _ 替代所有无需关注的值或变量”，以下是最典型的场景：
## out 参数：忽略无需使用的输出值
许多方法（如 int.TryParse、DateTime.TryParse）通过 out 参数返回额外结果，但有时我们只需要方法的返回值（如 “是否成功”），无需关注 out 输出。此时弃元可替代临时变量，避免冗余。
示例：验证字符串是否为有效整数，忽略解析结果：
```
string input = "123";
// 用 out _ 忽略解析出的整数，仅关注“是否成功”
if (int.TryParse(input, out _)) {
    Console.WriteLine("输入是有效整数");
}
```

传统方式需要声明 int temp; 并忽略，而弃元直接表达 “不需要结果” 的意图。
## 元组与对象解构：精准提取所需字段
元组或对象的解构常需提取部分字段，弃元可忽略无关项，避免声明无用变量。
### 示例 1：元组解构
从包含多字段的元组中仅提取 “名称” 和 “价格”，忽略其他：
```
// 方法返回 (id, 名称, 价格, 库存)
var (_, name, price, _) = GetProductInfo(1001);
Console.WriteLine($"商品：{name}，价格：{price}");
```

### 示例 2：对象解构
从 User 对象中提取 “用户名”，忽略 “ID” 和 “邮箱”：
```
var user = new User(1, "Alice", "alice@example.com");
// 解构时用 _ 忽略 ID 和邮箱
var (_, username, _) = user; 
Console.WriteLine($"用户名：{username}");
```

## switch 表达式：覆盖所有剩余情况
在 switch 表达式中，弃元 _ 作为 default 分支，匹配所有未被显式覆盖的情况。
示例：根据订单状态返回描述，用 _ 处理未知状态：
```
string GetOrderStatusDesc(OrderStatus status) => status switch {
    OrderStatus.Paid => "已支付",
    OrderStatus.Shipped => "已发货",
    OrderStatus.Delivered => "已送达",
    _ => "未知状态" // 弃元覆盖所有其他情况
};
```

## 忽略方法返回值
对于异步任务或有返回值但无需处理的方法，用 _ = 明确表示 “有意忽略结果”，避免编译器警告。
启动后台任务但不等待其完成，用弃元消除警告：
```
// 忽略任务的完成状态和可能的异常
_ = Task.Run(() => {
    // 耗时操作...
    Thread.Sleep(1000);
});
```

如果不将任务分配给弃元，则以下代码会生成编译器警告：
// CS4014: Because this call is not awaited, execution of the current method continues before the call is completed.
// Consider applying the 'await' operator to the result of the call.
## 强制空值检查
利用弃元验证参数非空，忽略赋值结果：
```
public void Process(string input) {
    // 若 input 为 null 则抛出异常，否则忽略赋值
    _ = input ?? throw new ArgumentNullException(nameof(input));
    // 处理 input...
}
```

上面写法等同于：
```
if (input == null)
{
    throw new ArgumentNullException(nameof(input));
}
```

### 为什么这种写法更好？
简洁性：将原本需要 3-4 行的 if 判断压缩成了一行代码，使代码更紧凑。
可读性（对熟悉语法的开发者而言）：一旦习惯了这种模式，它的意图非常清晰 ——“确保 input 不为 null，否则抛出异常”。它将校验逻辑封装成了一个原子操作。
现代 C# 风格：这是一种越来越被广泛接受和推荐的现代 C# 编码风格，充分利用了 C# 7.0 及以后版本的新特性。
# 弃元模式的核心优势
弃元的价值不仅在于语法简化，更体现在可读性、安全性和性能的多重提升。
## 可读性与维护性：明确 “忽略” 的意图
传统处理 “无需使用的值” 的方式（如 int temp; var unused;）存在歧义：读者需判断变量是否真的无用，还是 “暂时未使用但未来可能有用”。弃元用 _ 明确表示 “此值从设计上就无需关注”，强化认知。
例如，以下两段代码：
```
// 传统方式：歧义
int temp;
if (int.TryParse(input, out temp)) { ... }
// 弃元方式：意图清晰
if (int.TryParse(input, out _)) { ... }
```

后者无需解释 “temp 为何未被使用”，不存在歧义。
## 安全性：避免误用未使用的值
传统临时变量可能被误引用（如复制粘贴时的疏忽），导致逻辑错误。而弃元是 “不可访问的”，编译器会拦截任何对 _ 的使用，从语法层面杜绝误用。
```
// 错误示例：尝试使用弃元会编译报错
if (int.TryParse(input, out _)) {
    Console.WriteLine(_); // 编译错误：CS0103
}
```

## 性能：减少内存分配与 CPU 开销
弃元的核心性能优势源于编译器的针对性优化：对弃元，编译器会跳过内存分配和存储操作，直接减少资源消耗。
# 性能验证：弃元模式真的更快吗？
为验证弃元的性能优势，我们设计了两个高频场景的对比测试：out 参数处理和元组解构，通过百万级循环放大差异。
## 场景 1：out 参数处理（int.TryParse）
对比 “用临时变量接收 out 结果” 与 “用弃元忽略” 的耗时：
[![复制代码](https://assets.cnblogs.com/images/copycode.gif)](javascript:void\(0\); "复制代码")
```
static void TestOutParameter()
{
    const int loopCount = 10000000; // 1000万次循环
    string input = "12345";

    // 传统方式：用临时变量接收 out 结果
    var watch1 = Stopwatch.StartNew();
    for (int i = 0; i < loopCount; i++)
    {
        int temp;
        int.TryParse(input, out temp);
    }
    watch1.Stop();

    // 弃元方式：忽略 out 结果
    var watch2 = Stopwatch.StartNew();
    for (int i = 0; i < loopCount; i++)
    {
        int.TryParse(input, out _);
    }
    watch2.Stop();

    Console.WriteLine($"传统方式：{watch1.ElapsedMilliseconds} ms");
    Console.WriteLine($"弃元方式：{watch2.ElapsedMilliseconds} ms");
    Console.WriteLine($"性能提升：{((watch1.ElapsedMilliseconds - watch2.ElapsedMilliseconds) / (double)watch1.ElapsedMilliseconds):P2}");
}
```

[![复制代码](https://assets.cnblogs.com/images/copycode.gif)](javascript:void\(0\); "复制代码")
## ![01](https://img2024.cnblogs.com/blog/270073/202510/270073-20251009163022277-633079906.png)
## 场景 2：元组解构
对比 “声明所有元组成员” 与 “用弃元忽略无关项” 的耗时：
[![复制代码](https://assets.cnblogs.com/images/copycode.gif)](javascript:void\(0\); "复制代码")
```
static void TestTupleDeconstruction()
{
    const int loopCount = 10_000_000;
    var data = (id: 1, name: "test", price: 99.9, stock: 100); // 测试元组

    // 传统方式：声明所有成员（包含无用项）
    var watch1 = Stopwatch.StartNew();
    for (int i = 0; i < loopCount; i++)
    {
        var (id, name, price, stock) = data; // 声明4个变量，仅用name和price
        _ = name + price;
    }
    watch1.Stop();

    // 弃元方式：忽略无用成员
    var watch2 = Stopwatch.StartNew();
    for (int i = 0; i < loopCount; i++)
    {
        var (_, name, price, _) = data; // 仅声明需要的成员
        _ = name + price;
    }
    watch2.Stop();

    Console.WriteLine($"传统方式：{watch1.ElapsedMilliseconds} ms");
    Console.WriteLine($"弃元方式：{watch2.ElapsedMilliseconds} ms");
    Console.WriteLine($"性能提升：{((watch1.ElapsedMilliseconds - watch2.ElapsedMilliseconds) / (double)watch1.ElapsedMilliseconds):P2}");
}
```

[![复制代码](https://assets.cnblogs.com/images/copycode.gif)](javascript:void\(0\); "复制代码")
![02](https://img2024.cnblogs.com/blog/270073/202510/270073-20251009163049243-365530304.png)
# 底层影响：编译器如何优化弃元？
弃元的性能优势源于编译器（Roslyn）和 CLR 的深度优化，核心是 “识别 _ 并跳过不必要的操作”。
## 内存分配优化：不分配栈空间
对于值类型（如 int、struct），传统变量会在栈上分配内存，而弃元 _ 不会被分配任何内存 —— 编译器在生成 IL 代码时会直接忽略对 _ 的存储操作。
例如，int.TryParse(input, out _) 生成的 IL 代码中，不会包含为 out 参数分配栈空间的指令，而传统方式会有加载局部变量地址等指令。
## CPU 指令优化：减少存储操作
弃元会跳过值的 “存储” 和 “读取” 步骤。例如，元组解构时，var (_, name, _) = data 生成的 IL 代码仅包含对 name 的存储指令，而传统方式会包含所有成员的存储指令，减少了 CPU 执行的指令数。
## GC 友好：缩短对象生命周期
当您用一个局部变量接收一个引用类型，但之后不再使用它时，这个变量会一直持有对该对象的引用，直到方法结束。这会延长对象的生命周期，因为 GC 会认为这个对象 “仍在被使用”。弃元不会保留引用，堆对象可更早被 GC 回收，减少堆内存占用和 GC 压力。
## 完整性检查：编译期错误预防
在 switch 表达式中，编译器会检查弃元是否覆盖所有未匹配的情况（如枚举的所有值）。若存在未覆盖的值，会直接报错，避免运行时逻辑漏洞。
# 小结
弃元模式是 C# 中 “语法简洁性” 与 “性能优化” 结合的典范，其核心价值在于：
- **意图明确** ：用 _ 清晰表达 “无需关注的值”，提升代码可读性。
- **安全可靠** ：编译器拦截对弃元的误用，避免逻辑错误。
- **性能优异** ：减少内存分配和 CPU 指令，高频场景下提升 10%-30% 性能。
- **场景通用** ：覆盖 out 参数、元组解构、switch 表达式等多场景。
![me](https://img2024.cnblogs.com/blog/270073/202509/270073-20250926105511928-738986494.webp)
> **作者：**[MeteorSeed](http://www.cnblogs.com/MeteorSeed)
> **我希望您喜欢这篇博文，并一如既往地感谢您阅读并与朋友和同事分享我的博文。**
> **转载请注明出处。**
posted @ 2025-10-09 16:41 [MeteorSeed](https://www.cnblogs.com/MeteorSeed) 阅读(1949) 评论(5) [收藏](javascript:void\(0\)) [举报](javascript:void\(0\))
[刷新页面](https://www.cnblogs.com/MeteorSeed/p/19131402)[返回顶部](https://www.cnblogs.com/MeteorSeed/p/19131402#top)
登录后才能查看或发表评论，立即 [登录](javascript:void\(0\);) 或者 [逛逛](https://www.cnblogs.com/) 博客园首页 
[【推荐】诚邀您体验阿里巴巴推出的新一代 Agentic 编程平台 Qoder](https://www.cnblogs.com/cmt/p/19165152)  
[【推荐】博客园&小马算力达成战略合作，为开发者注入“算力引擎”](https://www.cnblogs.com/cmt/p/19154039)  
[【推荐】2025 HarmonyOS 创新赛正式启动，百万大奖等你来挑战！](https://www.cnblogs.com/cmt/p/19058738)  
[【推荐】天翼云智惠上云月，爆款云主机2核2G只要18.8元/3个月起](https://click.ctyun.cn/?track=source_bokeyuan-medium_cps-content_se1509618)  
[【推荐】鸿蒙应用开发者认证：学鸿蒙、考认证，跻身“抢手开发者”](https://developer.huawei.com/consumer/cn/training/classDetail/d6bfe940eba3442f8ddf79e91eea0a71?type=1?ha_source=hmosclass-bokeyuan&ha_sourceId=89000444)  

[ ![](https://img2024.cnblogs.com/blog/35695/202510/35695-20251013111242110-2029482428.jpg) ](https://qoder.com/)
### 公告
订阅号 ![](https://images.cnblogs.com/cnblogs_com/MeteorSeed/415190/o_seed_8cm.jpg)
昵称： [ MeteorSeed ](https://home.cnblogs.com/u/MeteorSeed/)   
园龄： [ 14年9个月 ](https://home.cnblogs.com/u/MeteorSeed/ "入园时间：2011-01-30")   
粉丝： [ 446 ](https://home.cnblogs.com/u/MeteorSeed/followers/)   
关注： [ 17 ](https://home.cnblogs.com/u/MeteorSeed/followees/)
|  [<](javascript:void\(0\);) | 2025年11月 |  [>](javascript:void\(0\);)  
---|---|---  
日 | 一 | 二 | 三 | 四 | 五 | 六  
26 | 27 | 28 | 29 | 30 | 31 |  1   
2  |  3  |  4  |  5  |  6  |  7  |  8   
9  |  10  |  11  |  12  |  13  |  14  |  15   
16  |  17  |  18  |  19  |  20  |  21  |  22   
23  |  24  |  25  |  26  |  27  |  28  |  29   
30  |  1  |  2  |  3  |  4  |  5  |  6   
[博客园](https://www.cnblogs.com/) © 2004-2025   
[![](https://assets.cnblogs.com/images/ghs.png)浙公网安备 33010602011771号](http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010602011771) [浙ICP备2021040463号-3](https://beian.miit.gov.cn)
点击右上角即可分享
![微信分享提示](https://img2023.cnblogs.com/blog/35695/202309/35695-20230906145857937-1471873834.gif)
